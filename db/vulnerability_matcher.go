package db

import (
	"database/sql"
	"fmt"
	"strings"

	"github.com/kaustgen/Integrating_AI_OSINT/matcher"
)

type VulnerableAsset struct {
	AssetID      string
	Hostname     string
	IPAddress    string
	CPEString    string
	AssetType    string
	CVEID        string
	CVSSScore    float32
	CVSSSeverity string
	Description  string
}

// FindVulnerableAssets performs two-stage CPE matching:
// 1. SQLite filters by vendor:product (fast, broad match)
// 2. Go does precise version matching (accurate, handles ranges)
func FindVulnerableAssets(db *sql.DB) ([]VulnerableAsset, error) {
	// Get all inventory items
	inventory, err := GetInventory(db)
	if err != nil {
		return nil, err
	}

	var results []VulnerableAsset

	for _, asset := range inventory {
		// Extract vendor:product from asset CPE for broad matching
		parts := strings.Split(asset.CPEString, ":")
		if len(parts) < 5 {
			continue
		}
		vendorProduct := strings.Join(parts[3:5], ":")

		// Find candidate CVEs (broad match on vendor:product)
		// This significantly reduces the number of CVEs we need to check precisely
		rows, err := db.Query(`
            SELECT DISTINCT 
                c.cve_id, 
                c.cvss_score, 
                c.cvss_severity, 
                c.description,
                cm.cpe_criteria,
                cm.version_start_including,
                cm.version_end_including,
                cm.version_start_excluding,
                cm.version_end_excluding
            FROM cves c
            JOIN cpe_matches cm ON c.cve_id = cm.cve_id
            WHERE cm.cpe_criteria LIKE ?
            AND cm.vulnerable = 1
        `, "%:"+vendorProduct+":%")

		if err != nil {
			return nil, err
		}

		for rows.Next() {
			var cveID, severity, desc, cveCPE string
			var score float32
			var vStartIncl, vEndIncl, vStartExcl, vEndExcl sql.NullString

			err := rows.Scan(&cveID, &score, &severity, &desc, &cveCPE,
				&vStartIncl, &vEndIncl, &vStartExcl, &vEndExcl)
			if err != nil {
				rows.Close()
				return nil, err
			}

			// Precise matching in Go with version range support
			isMatch, err := matcher.MatchCPE(
				asset.CPEString,
				cveCPE,
				vStartIncl.String,
				vEndIncl.String,
				vStartExcl.String,
				vEndExcl.String,
			)

			if err == nil && isMatch {
				results = append(results, VulnerableAsset{
					AssetID:      asset.AssetID,
					Hostname:     asset.Hostname,
					IPAddress:    asset.IPAddress,
					CPEString:    asset.CPEString,
					AssetType:    asset.AssetType,
					CVEID:        cveID,
					CVSSScore:    score,
					CVSSSeverity: severity,
					Description:  desc,
				})
			}
		}
		rows.Close()
	}

	return results, nil
}

// GetVulnerableAssetsSummary returns a count of vulnerabilities per asset
func GetVulnerableAssetsSummary(db *sql.DB) (map[string]int, error) {
	vulnAssets, err := FindVulnerableAssets(db)
	if err != nil {
		return nil, err
	}

	summary := make(map[string]int)
	for _, va := range vulnAssets {
		summary[va.AssetID]++
	}

	return summary, nil
}

// GetCriticalVulnerabilities returns only HIGH and CRITICAL severity vulnerabilities
func GetCriticalVulnerabilities(db *sql.DB) ([]VulnerableAsset, error) {
	allVulns, err := FindVulnerableAssets(db)
	if err != nil {
		return nil, err
	}

	var critical []VulnerableAsset
	for _, vuln := range allVulns {
		severity := strings.ToUpper(vuln.CVSSSeverity)
		if severity == "HIGH" || severity == "CRITICAL" {
			critical = append(critical, vuln)
		}
	}

	return critical, nil
}

// PrintVulnerabilityReport prints a formatted report of vulnerable assets
func PrintVulnerabilityReport(db *sql.DB) error {
	vulnAssets, err := FindVulnerableAssets(db)
	if err != nil {
		return err
	}

	if len(vulnAssets) == 0 {
		fmt.Println("\nâœ… No vulnerabilities found in inventory!")
		return nil
	}

	fmt.Printf("\nâš ï¸  Found %d vulnerabilities across inventory:\n\n", len(vulnAssets))

	// Group by asset
	assetVulns := make(map[string][]VulnerableAsset)
	for _, va := range vulnAssets {
		assetVulns[va.AssetID] = append(assetVulns[va.AssetID], va)
	}

	// Print by asset
	for assetID, vulns := range assetVulns {
		asset := vulns[0] // Get asset info from first entry
		fmt.Printf("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
		fmt.Printf("ðŸ–¥ï¸  Asset: %s (%s)\n", asset.Hostname, assetID)
		fmt.Printf("    IP: %s | Type: %s\n", asset.IPAddress, asset.AssetType)
		fmt.Printf("    CPE: %s\n", asset.CPEString)
		fmt.Printf("    Vulnerabilities: %d\n\n", len(vulns))

		for i, vuln := range vulns {
			severity := vuln.CVSSSeverity
			icon := "ðŸ”µ"
			if severity == "CRITICAL" {
				icon = "ðŸ”´"
			} else if severity == "HIGH" {
				icon = "ðŸŸ "
			} else if severity == "MEDIUM" {
				icon = "ðŸŸ¡"
			}

			fmt.Printf("    %d. %s %s [%s] - CVSS %.1f\n",
				i+1, icon, vuln.CVEID, severity, vuln.CVSSScore)

			// Truncate description
			desc := vuln.Description
			if len(desc) > 100 {
				desc = desc[:97] + "..."
			}
			fmt.Printf("       %s\n", desc)

			if i < len(vulns)-1 {
				fmt.Println()
			}
		}
		fmt.Println()
	}

	return nil
}
