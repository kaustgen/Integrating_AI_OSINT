// Author: Kaleb Austgen
// Date Created: 12/28/25
// Purpose: Vulnerability matching logic between inventory assets and CVE entries with KEV integration

package db

import (
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/kaustgen/Integrating_AI_OSINT/matcher"
)

// VulnerableAsset represents an inventory asset with a matched CVE
// Includes both NVD vulnerability data and KEV (Known Exploited Vulnerabilities) metadata
type VulnerableAsset struct {
	// Asset information
	AssetID        string
	Hostname       string
	IPAddress      string
	CPEString      string
	AssetType      string
	InternetFacing bool

	// CVE/NVD information
	CVEID        string
	CVSSScore    float32
	CVSSSeverity string
	Description  string

	// KEV (Known Exploited Vulnerabilities) information
	// These fields are populated if the CVE is actively being exploited
	InKEV        bool   // True if this CVE is in CISA's KEV catalog
	KEVDateAdded string // When CISA confirmed active exploitation
	KEVDueDate   string // Federal remediation deadline
	KEVAction    string // Required remediation action from CISA
	IsRansomware bool   // True if used in ransomware campaigns

	// Shodan exposure data (internet visibility confirmation)
	// These fields validate external discoverability
	ShodanIndexed bool     // Is this IP visible on Shodan?
	ShodanPorts   []int    // Open ports Shodan detected
	ShodanCVEs    []string // CVEs Shodan detected (cross-reference)

	// GreyNoise threat intelligence (active exploitation attempts)
	// These fields show real-world attack activity against this CVE
	GreyNoiseActive         bool           // Are malicious IPs actively scanning?
	GreyNoiseScanCount      int            // Total scanning IPs detected
	GreyNoiseTags           []string       // Attack tags (exploit, ransomware, botnet)
	GreyNoiseCountries      map[string]int // Scanner origin countries with counts
	GreyNoiseRansomware     bool           // Ransomware actors scanning?
	GreyNoiseRecentActivity bool           // Scanned in last 24 hours?
}

// FindVulnerableAssets performs two-stage CPE matching with KEV integration:
// 1. SQLite filters by vendor:product (fast, broad match) and LEFT JOINs KEV data
// 2. Go does precise version matching (accurate, handles semantic versioning ranges)
//
// Algorithm:
//   - For each inventory asset, extract vendor:product from its CPE string
//   - Query database for candidate CVEs matching that vendor:product
//   - Include KEV data via LEFT JOIN (NULL if CVE not in KEV)
//   - Perform precise version comparison in Go using semantic versioning
//   - Return matches with complete vulnerability + KEV metadata
//
// Returns vulnerabilities sorted with KEV entries prioritized first
func FindVulnerableAssets(db *sql.DB) ([]VulnerableAsset, error) {
	// Get all inventory items
	inventory, err := GetInventory(db)
	if err != nil {
		return nil, err
	}

	var results []VulnerableAsset

	// Iterate through each asset in inventory
	for _, asset := range inventory {
		// Extract vendor:product from asset CPE for broad SQL matching
		// Example: "cpe:2.3:a:apache:http_server:2.4.49" ‚Üí "apache:http_server"
		parts := strings.Split(asset.CPEString, ":")
		if len(parts) < 5 {
			continue // Invalid CPE format, skip this asset
		}
		vendorProduct := strings.Join(parts[3:5], ":")

		// SQL Query: Broad match on vendor:product with KEV data inclusion
		// LEFT JOIN ensures we get all CVEs, with KEV data where available
		// This is the KEY modification for KEV integration
		rows, err := db.Query(`
            SELECT DISTINCT 
                c.cve_id, 
                c.cvss_score, 
                c.cvss_severity, 
                c.description,
                cm.cpe_criteria,
                cm.version_start_including,
                cm.version_end_including,
                cm.version_start_excluding,
                cm.version_end_excluding,
                -- KEV fields (will be NULL if CVE not in KEV)
                kev.cve_id IS NOT NULL as in_kev,
                COALESCE(kev.date_added, '') as kev_date_added,
                COALESCE(kev.due_date, '') as kev_due_date,
                COALESCE(kev.required_action, '') as kev_action,
                COALESCE(kev.known_ransomware, 0) as is_ransomware
            FROM cves c
            JOIN cpe_matches cm ON c.cve_id = cm.cve_id
            LEFT JOIN kev_catalog kev ON c.cve_id = kev.cve_id  -- Include KEV data
            WHERE cm.cpe_criteria LIKE ?
            AND cm.vulnerable = 1
        `, "%:"+vendorProduct+":%")

		if err != nil {
			return nil, err
		}

		// Process each candidate CVE from SQL results
		for rows.Next() {
			var cveID, severity, desc, cveCPE string
			var score float32
			var vStartIncl, vEndIncl, vStartExcl, vEndExcl sql.NullString
			// KEV fields
			var inKEV bool
			var kevDateAdded, kevDueDate, kevAction string
			var isRansomware int

			// Scan row data including KEV fields
			err := rows.Scan(
				&cveID, &score, &severity, &desc, &cveCPE,
				&vStartIncl, &vEndIncl, &vStartExcl, &vEndExcl,
				&inKEV, &kevDateAdded, &kevDueDate, &kevAction, &isRansomware,
			)
			if err != nil {
				rows.Close()
				return nil, err
			}

			// Precise CPE matching in Go (handles semantic versioning)
			// This validates that the asset's version actually falls within
			// the vulnerable version range specified by the CVE
			isMatch, err := matcher.MatchCPE(
				asset.CPEString,
				cveCPE,
				vStartIncl.String,
				vEndIncl.String,
				vStartExcl.String,
				vEndExcl.String,
			)

			if err != nil || !isMatch {
				continue // Not a match or error in version comparison
			}

			// Match confirmed! Add to results with complete metadata
			results = append(results, VulnerableAsset{
				AssetID:        asset.AssetID,
				Hostname:       asset.Hostname,
				IPAddress:      asset.IPAddress,
				CPEString:      asset.CPEString,
				AssetType:      asset.AssetType,
				InternetFacing: asset.InternetFacing,
				CVEID:          cveID,
				CVSSScore:      score,
				CVSSSeverity:   severity,
				Description:    desc,
				// KEV metadata (will be default values if not in KEV)
				InKEV:        inKEV,
				KEVDateAdded: kevDateAdded,
				KEVDueDate:   kevDueDate,
				KEVAction:    kevAction,
				IsRansomware: isRansomware == 1,
			})
		}
		rows.Close()
	}

	return results, nil
}

// GetVulnerableAssetsSummary returns a count of vulnerabilities per asset
func GetVulnerableAssetsSummary(db *sql.DB) (map[string]int, error) {
	vulnAssets, err := FindVulnerableAssets(db)
	if err != nil {
		return nil, err
	}

	summary := make(map[string]int)
	for _, va := range vulnAssets {
		summary[va.AssetID]++
	}

	return summary, nil
}

// GetCriticalVulnerabilities returns only HIGH and CRITICAL severity vulnerabilities
func GetCriticalVulnerabilities(db *sql.DB) ([]VulnerableAsset, error) {
	allVulns, err := FindVulnerableAssets(db)
	if err != nil {
		return nil, err
	}

	var critical []VulnerableAsset
	for _, vuln := range allVulns {
		severity := strings.ToUpper(vuln.CVSSSeverity)
		if severity == "HIGH" || severity == "CRITICAL" {
			critical = append(critical, vuln)
		}
	}

	return critical, nil
}

// PrintVulnerabilityReport generates a prioritized vulnerability report
// Separates KEV (actively exploited) vulnerabilities from regular CVEs
// KEV vulnerabilities are displayed first as they require immediate action
func PrintVulnerabilityReport(db *sql.DB) error {
	vulnAssets, err := FindVulnerableAssets(db)
	if err != nil {
		return err
	}

	return PrintVulnerabilityReportWithVulns(vulnAssets)
}

// PrintVulnerabilityReportWithVulns generates report from pre-computed vulnerabilities
// This is used when we've already enhanced vulnerabilities with Shodan data
// Separates KEV (actively exploited) from regular vulnerabilities
func PrintVulnerabilityReportWithVulns(vulnAssets []VulnerableAsset) error {
	if len(vulnAssets) == 0 {
		fmt.Println("\n‚úÖ No vulnerabilities found in inventory!")
		return nil
	}

	// Sort vulnerabilities by priority (KEV first)
	vulnAssets = SortVulnerabilitiesByPriority(vulnAssets)

	// Separate KEV and non-KEV vulnerabilities
	var kevVulns, regularVulns []VulnerableAsset
	for _, v := range vulnAssets {
		if v.InKEV {
			kevVulns = append(kevVulns, v)
		} else {
			regularVulns = append(regularVulns, v)
		}
	}

	// Print report header with statistics
	fmt.Println("\n" + strings.Repeat("=", 70))
	fmt.Println("           VULNERABILITY ASSESSMENT REPORT")
	fmt.Println(strings.Repeat("=", 70))
	fmt.Printf("\nTotal Vulnerabilities: %d\n", len(vulnAssets))
	fmt.Printf("üî• Actively Exploited (KEV): %d\n", len(kevVulns))
	fmt.Printf("‚ö†Ô∏è  Other Vulnerabilities: %d\n", len(regularVulns))

	// Print KEV vulnerabilities first (HIGHEST PRIORITY)
	if len(kevVulns) > 0 {
		fmt.Println("\n" + strings.Repeat("=", 70))
		fmt.Println("üö® ACTIVELY EXPLOITED VULNERABILITIES (KEV)")
		fmt.Println("   These CVEs are being exploited in the wild RIGHT NOW")
		fmt.Println("   ‚ö†Ô∏è  IMMEDIATE ACTION REQUIRED ‚ö†Ô∏è")
		fmt.Println(strings.Repeat("=", 70))
		printVulnerabilityGroup(kevVulns, true)
	}

	// Print regular vulnerabilities (lower priority)
	if len(regularVulns) > 0 {
		fmt.Println("\n" + strings.Repeat("=", 70))
		fmt.Println("‚ö†Ô∏è  OTHER VULNERABILITIES")
		fmt.Println("   No confirmed active exploitation")
		fmt.Println("   Schedule remediation per normal process")
		fmt.Println(strings.Repeat("=", 70))
		printVulnerabilityGroup(regularVulns, false)
	}

	return nil
}

// SortVulnerabilitiesByPriority sorts vulnerabilities with KEV entries first
// Priority calculation considers:
//   - KEV status (massive boost)
//   - GreyNoise active exploitation (high boost)
//   - GreyNoise mass campaigns (>1000 IPs)
//   - Ransomware usage (additional boost)
//   - Due date status (overdue = more urgent)
//   - Internet-facing (higher attack surface)
//   - CVSS score (severity)
func SortVulnerabilitiesByPriority(vulns []VulnerableAsset) []VulnerableAsset {
	// Calculate priority score for each vulnerability
	type scoredVuln struct {
		vuln  VulnerableAsset
		score int
	}

	scored := make([]scoredVuln, len(vulns))
	for i, v := range vulns {
		score := 0

		// KEV status (huge priority boost - actively exploited)
		if v.InKEV {
			score += 1000

			// Ransomware campaigns (extra critical)
			if v.IsRansomware {
				score += 500
			}

			// Check if past due date (compliance violation)
			if isPastDue(v.KEVDueDate) {
				score += 300
			}
		}

		// GreyNoise active exploitation (verified malicious scanning)
		// Strong signal of imminent attack attempts
		if v.GreyNoiseActive {
			score += 500

			// Mass campaign (>1000 scanning IPs = widespread targeting)
			if v.GreyNoiseScanCount > 1000 {
				score += 300
			}

			// Recent activity (last 24 hours = actively being exploited NOW)
			if v.GreyNoiseRecentActivity {
				score += 200
			}

			// Ransomware actors scanning (extremely high risk)
			if v.GreyNoiseRansomware {
				score += 400
			}
		}

		// Shodan indexed (verified external exposure)
		// Higher priority than generic internet-facing because it's confirmed
		if v.ShodanIndexed {
			score += 400
		}

		// Internet-facing assets have higher attack surface
		// Lower than Shodan-indexed (this is unverified)
		if v.InternetFacing {
			score += 200
		}

		// CVSS score contribution (0-100 points)
		score += int(v.CVSSScore * 10)

		scored[i] = scoredVuln{vuln: v, score: score}
	}

	// Sort by score descending (highest priority first)
	// Using bubble sort (sufficient for typical vulnerability counts)
	for i := 0; i < len(scored); i++ {
		for j := i + 1; j < len(scored); j++ {
			if scored[i].score < scored[j].score {
				scored[i], scored[j] = scored[j], scored[i]
			}
		}
	}

	// Extract sorted vulnerabilities
	result := make([]VulnerableAsset, len(scored))
	for i, s := range scored {
		result[i] = s.vuln
	}

	return result
}

// printVulnerabilityGroup prints formatted vulnerability list
// isKEV parameter controls whether to show KEV-specific metadata
func printVulnerabilityGroup(vulns []VulnerableAsset, isKEV bool) {
	// Group vulnerabilities by asset
	assetVulns := make(map[string][]VulnerableAsset)
	for _, v := range vulns {
		assetVulns[v.AssetID] = append(assetVulns[v.AssetID], v)
	}

	// Print each asset's vulnerabilities
	for _, vulnList := range assetVulns {
		asset := vulnList[0] // Get asset info from first vulnerability

		// Asset header with internet-facing and Shodan indicators
		internetStatus := ""
		if asset.InternetFacing {
			internetStatus = " üåê INTERNET-FACING"

			// Add Shodan indexed indicator if confirmed
			if asset.ShodanIndexed {
				internetStatus += " üîç SHODAN-INDEXED"
			}
		}

		fmt.Printf("\n%s %s (%s)%s\n",
			getAssetIcon(asset.AssetType),
			asset.Hostname,
			asset.IPAddress,
			internetStatus)
		fmt.Printf("   CPE: %s\n", asset.CPEString)

		// Show Shodan port exposure if available
		if asset.ShodanIndexed && len(asset.ShodanPorts) > 0 {
			fmt.Printf("   Shodan Ports: %v\n", asset.ShodanPorts)
		}

		// Print each CVE
		for i, vuln := range vulnList {
			isLast := i == len(vulnList)-1
			prefix := "‚îú‚îÄ"
			if isLast {
				prefix = "‚îî‚îÄ"
			}

			// CVE header with colored severity
			color := getSeverityColor(vuln.CVSSSeverity)
			fmt.Printf("   %s %s [%s%s - %.1f%s]\n",
				prefix,
				vuln.CVEID,
				color,
				vuln.CVSSSeverity,
				vuln.CVSSScore,
				colorReset)

			// KEV-specific information (only shown for actively exploited CVEs)
			if isKEV {
				subPrefix := "‚îÇ  "
				if isLast {
					subPrefix = "   "
				}

				fmt.Printf("   %s‚îú‚îÄ üî• ACTIVELY EXPLOITED\n", subPrefix)
				fmt.Printf("   %s‚îú‚îÄ Added to KEV: %s\n", subPrefix, vuln.KEVDateAdded)

				// Due date with overdue warning
				if isPastDue(vuln.KEVDueDate) {
					fmt.Printf("   %s‚îú‚îÄ ‚è∞ Due Date: %s ‚ùå OVERDUE\n", subPrefix, vuln.KEVDueDate)
				} else {
					fmt.Printf("   %s‚îú‚îÄ Due Date: %s\n", subPrefix, vuln.KEVDueDate)
				}

				// Ransomware campaign indicator
				if vuln.IsRansomware {
					fmt.Printf("   %s‚îú‚îÄ üíÄ KNOWN RANSOMWARE CAMPAIGN\n", subPrefix)
				}

				// GreyNoise threat intelligence (active attack data)
				if vuln.GreyNoiseActive {
					fmt.Printf("   %s‚îú‚îÄ üéØ ACTIVE EXPLOITATION ATTEMPTS DETECTED\n", subPrefix)
					fmt.Printf("   %s‚îÇ  ‚îú‚îÄ %d malicious IPs actively scanning\n",
						subPrefix, vuln.GreyNoiseScanCount)

					// Mass campaign indicator
					if vuln.GreyNoiseScanCount > 1000 {
						fmt.Printf("   %s‚îÇ  ‚îú‚îÄ ‚ö†Ô∏è  MASS CAMPAIGN (>1000 IPs)\n", subPrefix)
					}

					// Recent activity warning
					if vuln.GreyNoiseRecentActivity {
						fmt.Printf("   %s‚îÇ  ‚îú‚îÄ üî¥ SCANNED IN LAST 24 HOURS\n", subPrefix)
					}

					// Ransomware actor warning
					if vuln.GreyNoiseRansomware {
						fmt.Printf("   %s‚îÇ  ‚îú‚îÄ üíÄ RANSOMWARE ACTORS SCANNING\n", subPrefix)
					}

					// Display tags
					if len(vuln.GreyNoiseTags) > 0 {
						fmt.Printf("   %s‚îÇ  ‚îú‚îÄ Tags: %v\n", subPrefix, vuln.GreyNoiseTags)
					}

					// Display top countries
					if len(vuln.GreyNoiseCountries) > 0 {
						fmt.Printf("   %s‚îÇ  ‚îî‚îÄ Top Sources: ", subPrefix)
						count := 0
						for country, ips := range vuln.GreyNoiseCountries {
							if count > 0 {
								fmt.Print(", ")
							}
							fmt.Printf("%s (%d)", country, ips)
							count++
							if count >= 3 { // Show top 3 countries
								break
							}
						}
						fmt.Println()
					}
				}

				fmt.Printf("   %s‚îú‚îÄ Action: %s\n", subPrefix, vuln.KEVAction)
				fmt.Printf("   %s‚îî‚îÄ %s\n", subPrefix, truncate(vuln.Description, 70))
			} else {
				// Non-KEV: Just show description
				subPrefix := "‚îÇ  "
				if isLast {
					subPrefix = "   "
				}
				fmt.Printf("   %s‚îî‚îÄ %s\n", subPrefix, truncate(vuln.Description, 70))
			}
		}
	}
}

// isPastDue checks if a KEV due date has passed
func isPastDue(dueDate string) bool {
	if dueDate == "" {
		return false
	}

	// Parse CISA's date format (YYYY-MM-DD)
	due, err := time.Parse("2006-01-02", dueDate)
	if err != nil {
		return false
	}

	return time.Now().After(due)
}

// getAssetIcon returns an emoji icon for different asset types
func getAssetIcon(assetType string) string {
	icons := map[string]string{
		"endpoint":           "üíª",
		"web_server":         "üåê",
		"application_server": "üñ•Ô∏è",
		"router":             "üîÄ",
		"database":           "üóÑÔ∏è",
		"inventory_system":   "‚öôÔ∏è",
	}
	if icon, ok := icons[assetType]; ok {
		return icon
	}
	return "üì¶"
}

// getSeverityColor returns ANSI color code for severity levels
func getSeverityColor(severity string) string {
	colors := map[string]string{
		"CRITICAL": "\033[31m", // Red
		"HIGH":     "\033[33m", // Yellow
		"MEDIUM":   "\033[34m", // Blue
		"LOW":      "\033[37m", // White
	}
	if color, ok := colors[severity]; ok {
		return color
	}
	return ""
}

const colorReset = "\033[0m"

// truncate shortens strings to specified length with ellipsis
func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}
